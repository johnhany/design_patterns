# design_patterns

C++实现的22种设计模式

代码改写自[《深入设计模式》](https://refactoring.guru/design-patterns)

为了便于理解，所有代码以机器学习模型的构建\训练过程为例

## 创建型模式（Creational patterns）

主要关注对象创建过程的灵活性和可复用性。

### 工厂方法（Factory method）

适用于将对象的创建和使用分离，并希望尽可能多地复用现有代码来处理新型对象的情景。`工厂方法模式`可以演化为`抽象工厂模式`、`生成器模式`和`原型模式`。

### 抽象工厂（Abstract factory）

适用于需要创建许多种一系列相互依赖的对象的情景。`工厂方法`与`抽象工厂`的根本区别在于`工厂方法`是“方法”，`抽象工厂`是“对象”。具体地，`工厂方法`的目的在于用基类的不同子类来表示不同的对象；`抽象工厂`只需要关心如何创建一系列相互依赖的对象，可以理解为一种包含很多`工厂方法`的对象。

### 生成器（Builder）

适用于需要分很多步骤创建不同对象的情景。

### 原型（Prototype）

适用于需要复制复杂的对象，并希望新复制的对象独立于原来的代码的情景。

### 单例（Singleton）

适用于一个类只需要一个实例的情景。但多线程下不能保证所有线程只有一个实例（C++11之前）。`抽象工厂模式`、`生成器模式`和`原型模式`都可以用`单例`实现。

## Structural patterns

### 适配器（Adapter）

适用于使现有代码调用不兼容的类（比如遗留代码、第三方库等）。

## Behavioral patterns
